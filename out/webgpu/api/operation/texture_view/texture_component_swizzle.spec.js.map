{"version":3,"file":"texture_component_swizzle.spec.js","names":["description","makeTestGroup","assert","range","unreachable","isSintOrUintFormat","isDepthOrStencilTextureFormat","kAllTextureFormats","isDepthTextureFormat","getBlockInfoForTextureFormat","isStencilTextureFormat","isDepthStencilTextureFormat","AllFeaturesMaxLimitsGPUTest","applyCompareToTexel","chooseTextureSize","convertPerTexelComponentToResultFormat","createTextureWithRandomDataAndGetTexelsForEachAspect","getTextureFormatTypeInfo","isBuiltinComparison","isBuiltinGather","isFillable","ttu","TexelComponent","TexelView","kSwizzleTests","swizzlesAreTheSame","swizzleSpecToGPUTextureComponentSwizzle","swizzleTexel","altResultForSwizzle","component","isSingleChannelInput","input","makeValidMaskAndAltResultForFormatSwizzle","swizzle","format","func","gatherChannel","validMask","altResult","swizzleByChannel","r","g","b","a","rgbaDepthMask","componentChannel","channel","applyValidMask","texel","R","G","B","A","getSwizzleSpecByOffsetFromSwizzleSpec","swizzleSpec","offset","indexOf","length","kTextureBuiltinFunctions","canBuiltinTakeTextureDepth","canUseBuiltinFuncWithFormat","aspect","effectiveFormat","channelIndexToTexelComponent","Error","getColorByChannelIndex","v","undefined","gather","srcColors","noDefinedResults","every","kGatherComponentOrder","s_deviceToPipelines","WeakMap","test","desc","params","u","combine","filter","t","beginSubcases","expand","componentType","unless","otherSwizzleIndexOffset","fn","skipIfDeviceDoesNotHaveFeature","compare","skipIfTextureFormatNotSupported","otherSwizzleSpec","otherSwizzle","skipIf","isCompatibility","depthRef","size","minSize","minBlocks","blockWidth","blockHeight","tx","ty","descriptor","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","texels","srcTexelViews","texture","aspectNdx","srcTexelView","samples","sampledColors","i","x","y","sample","color","z","push","debug","map","c","JSON","stringify","join","components","readColors","sampledColor","resultType","sampleType","srcSampleType","resultFormat","expFormat","testData","swizzledColors","readColor","gatheredColor","expRGBAColor","expColor","expTexelView","fromTexelsAsColors","_coords","textureView","createView","loadFn","loadWGSL","samplerWGSL","code","samplerType","pipelineId","cache","get","device","Map","set","pipeline","module","createShaderModule","bgl0","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","VERTEX","sampler","type","buffer","storageTexture","bgl1","layout","createPipelineLayout","bindGroupLayouts","createRenderPipeline","vertex","fragment","targets","primitive","topology","outputTexture","createTextureTracked","COPY_SRC","STORAGE_BINDING","createSampler","uniformBuffer","createBufferTracked","GPUBufferUsage","UNIFORM","uniformValues","ArrayBuffer","asU32","Uint32Array","asF32","Float32Array","flat","width","height","queue","writeBuffer","bindGroup0","createBindGroup","getBindGroupLayout","resource","bindGroup1","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","RENDER_ATTACHMENT","loadOp","storeOp","setPipeline","setBindGroup","draw","end","expectValidationError","submit","finish","forEach","expectTexelViewComparisonIsOkInTexture","origin","maxFractionalDiff"],"sources":["../../../../../src/webgpu/api/operation/texture_view/texture_component_swizzle.spec.ts"],"sourcesContent":["export const description = `\nOperational tests for the 'texture-component-swizzle' feature.\n\nTest that:\n* when the feature is on, swizzling is applied correctly.\n\nTODO:\n* test stencil aspect of depth-stencil formats\n* test texture_depth_xxx with textureSample\n* test texture_2d<f32> with textureGatherCompare\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, range, unreachable } from '../../../../common/util/util.js';\nimport {\n  isSintOrUintFormat,\n  isDepthOrStencilTextureFormat,\n  kAllTextureFormats,\n  isDepthTextureFormat,\n  getBlockInfoForTextureFormat,\n  isStencilTextureFormat,\n  isDepthStencilTextureFormat,\n} from '../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport {\n  applyCompareToTexel,\n  chooseTextureSize,\n  convertPerTexelComponentToResultFormat,\n  createTextureWithRandomDataAndGetTexelsForEachAspect,\n  getTextureFormatTypeInfo,\n  isBuiltinComparison,\n  isBuiltinGather,\n  isFillable,\n  TextureBuiltin,\n} from '../../../shader/execution/expression/call/builtin/texture_utils.js';\nimport * as ttu from '../../../texture_test_utils.js';\nimport { PerTexelComponent, TexelComponent } from '../../../util/texture/texel_data.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\nimport {\n  kSwizzleTests,\n  swizzlesAreTheSame,\n  swizzleSpecToGPUTextureComponentSwizzle,\n  SwizzleSpec,\n  swizzleTexel,\n} from '../../validation/capability_checks/features/texture_component_swizzle_utils.js';\n\nfunction altResultForSwizzle(component: GPUComponentSwizzle): number {\n  switch (component) {\n    case 'zero':\n      return 0;\n    case 'one':\n      return 1;\n    case 'r':\n      return 0;\n    case 'g':\n      return 0;\n    case 'b':\n      return 0;\n    case 'a':\n      return 1;\n  }\n}\n\ntype TextureInput = 'texture_2d<f32>' | 'texture_2d<u32>' | 'texture_2d<i32>' | 'texture_depth_2d';\n\nfunction isSingleChannelInput(input: TextureInput) {\n  return input === 'texture_depth_2d';\n}\n\n// This returns a validMask vec4u for if a channel is valid (1) or not-valid (0)\n// and for each channel that is not-valid it returns the value we will expect the\n// shader to write. The shader chooses either the value sampled/read if valid, OR\n// the altResult if not valid. For depth and stencil textures, G, B, and A are not\n// valid.\nexport function makeValidMaskAndAltResultForFormatSwizzle(\n  swizzle: GPUTextureComponentSwizzle,\n  format: GPUTextureFormat,\n  func: TextureBuiltin,\n  input: TextureInput,\n  gatherChannel: number\n) {\n  if (!isDepthOrStencilTextureFormat(format)) {\n    return {\n      validMask: [1, 1, 1, 1],\n      altResult: [0, 0, 0, 0],\n    };\n  }\n  const swizzleByChannel = [swizzle.r ?? 'r', swizzle.g ?? 'g', swizzle.b ?? 'b', swizzle.a ?? 'a'];\n  const rgbaDepthMask = {\n    validMask: range(4, componentChannel => {\n      const channel = isBuiltinGather(func) ? gatherChannel : componentChannel;\n      const component = swizzleByChannel[channel];\n      return component === 'g' || component === 'b' || component === 'a' ? 0 : 1;\n    }),\n    altResult: [\n      altResultForSwizzle(swizzle.r ?? 'r'),\n      altResultForSwizzle(swizzle.g ?? 'g'),\n      altResultForSwizzle(swizzle.b ?? 'b'),\n      altResultForSwizzle(swizzle.a ?? 'a'),\n    ],\n  };\n  return !isBuiltinGather(func) && isSingleChannelInput(input)\n    ? {\n        validMask: [\n          rgbaDepthMask.validMask[0],\n          rgbaDepthMask.validMask[0],\n          rgbaDepthMask.validMask[0],\n          rgbaDepthMask.validMask[0],\n        ],\n        altResult: [\n          rgbaDepthMask.altResult[0],\n          rgbaDepthMask.altResult[0],\n          rgbaDepthMask.altResult[0],\n          rgbaDepthMask.altResult[0],\n        ],\n      }\n    : rgbaDepthMask;\n}\n\nfunction applyValidMask(\n  texel: PerTexelComponent<number>,\n  validMask: ReturnType<typeof makeValidMaskAndAltResultForFormatSwizzle>\n): PerTexelComponent<number> {\n  return {\n    R: validMask.validMask[0] ? texel.R : validMask.altResult[0],\n    G: validMask.validMask[1] ? texel.G : validMask.altResult[1],\n    B: validMask.validMask[2] ? texel.B : validMask.altResult[2],\n    A: validMask.validMask[3] ? texel.A : validMask.altResult[3],\n  };\n}\n\nfunction getSwizzleSpecByOffsetFromSwizzleSpec(\n  swizzleSpec: SwizzleSpec,\n  offset: number\n): SwizzleSpec {\n  return kSwizzleTests[(kSwizzleTests.indexOf(swizzleSpec) + offset) % kSwizzleTests.length];\n}\n\nconst kTextureBuiltinFunctions = [\n  'textureGather',\n  'textureGatherCompare',\n  'textureLoad',\n  'textureSample',\n  'textureSampleBias',\n  'textureSampleCompare',\n  'textureSampleCompareLevel',\n  'textureSampleGrad',\n  'textureSampleLevel',\n  // 'textureSampleBaseClampToEdge',  // external textures don't have a view to swizzle.\n] as const;\n\nfunction canBuiltinTakeTextureDepth(func: TextureBuiltin) {\n  return (\n    func === 'textureGather' ||\n    func === 'textureGatherCompare' ||\n    func === 'textureLoad' ||\n    func === 'textureSample' ||\n    func === 'textureSampleCompare' ||\n    func === 'textureSampleCompareLevel' ||\n    func === 'textureSampleLevel'\n  );\n}\n\nfunction canUseBuiltinFuncWithFormat(\n  func: TextureBuiltin,\n  format: GPUTextureFormat,\n  aspect: GPUTextureAspect\n) {\n  const effectiveFormat = aspect === 'stencil-only' ? 'stencil8' : format;\n  if (isSintOrUintFormat(effectiveFormat)) {\n    return func === 'textureGather' || func === 'textureLoad';\n  } else if (!isDepthTextureFormat(effectiveFormat)) {\n    return (\n      func !== 'textureGatherCompare' &&\n      func !== 'textureSampleCompare' &&\n      func !== 'textureSampleCompareLevel'\n    );\n  } else {\n    return true;\n  }\n}\n\nfunction channelIndexToTexelComponent(channel: number): TexelComponent {\n  switch (channel) {\n    case 0:\n      return TexelComponent.R;\n    case 1:\n      return TexelComponent.G;\n    case 2:\n      return TexelComponent.B;\n    case 3:\n      return TexelComponent.A;\n    default:\n      throw new Error(`Invalid channel index: ${channel}`);\n  }\n}\n\nfunction getColorByChannelIndex(texel: PerTexelComponent<number>, channel: number): number {\n  const component = channelIndexToTexelComponent(channel);\n  const v = texel[component];\n  assert(v !== undefined);\n  return v;\n}\n\nfunction gather(\n  srcColors: PerTexelComponent<number>[],\n  channel: number\n): PerTexelComponent<number> {\n  //   texel gather offsets\n  // r [0, 1] 2\n  // g [1, 1] 3\n  // b [1, 0] 1\n  // a [0, 0] 0\n  return {\n    R: getColorByChannelIndex(srcColors[2], channel),\n    G: getColorByChannelIndex(srcColors[3], channel),\n    B: getColorByChannelIndex(srcColors[1], channel),\n    A: getColorByChannelIndex(srcColors[0], channel),\n  };\n}\n\nfunction noDefinedResults(\n  swizzleSpec: SwizzleSpec,\n  format: GPUTextureFormat,\n  func: TextureBuiltin,\n  input: TextureInput,\n  channel: number\n) {\n  const swizzle = swizzleSpecToGPUTextureComponentSwizzle(swizzleSpec);\n  const validMask = makeValidMaskAndAltResultForFormatSwizzle(\n    swizzle,\n    format,\n    func,\n    input,\n    channel\n  );\n  return validMask.validMask.every(v => v === 0);\n}\n\nconst kGatherComponentOrder = ['B', 'A', 'R', 'G'] as const;\n\ntype PipelineCache = Map<string, GPUComputePipeline | GPURenderPipeline>;\nconst s_deviceToPipelines = new WeakMap<GPUDevice, PipelineCache>();\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\ng.test('read_swizzle')\n  .desc(\n    `\n  Test reading textures with swizzles.\n  * Test that multiple swizzles of the same texture work.\n  * Test that multiple swizzles of the same fails in compat if the swizzles are different.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isFillable(t.format))\n      .combine('func', kTextureBuiltinFunctions)\n      .beginSubcases()\n      .expand('compare', function* (t) {\n        if (isBuiltinComparison(t.func)) {\n          yield 'less';\n          yield 'greater';\n        } else {\n          yield 'always';\n        }\n      })\n      .expand('aspect', function* (t) {\n        if (isDepthOrStencilTextureFormat(t.format)) {\n          if (isDepthTextureFormat(t.format)) {\n            yield 'depth-only';\n          }\n          if (isStencilTextureFormat(t.format)) {\n            yield 'stencil-only';\n          }\n        } else {\n          yield 'all';\n        }\n      })\n      .filter(t => canUseBuiltinFuncWithFormat(t.func, t.format, t.aspect))\n      .expand('input', function* (t) {\n        if (!isBuiltinComparison(t.func)) {\n          const { componentType } = getTextureFormatTypeInfo(t.format, t.aspect);\n          switch (componentType) {\n            case 'f32':\n              yield `texture_2d<f32>`;\n              break;\n            case 'u32':\n              yield `texture_2d<u32>`;\n              break;\n            case 'i32':\n              yield `texture_2d<i32>`;\n              break;\n            default:\n              unreachable();\n          }\n        }\n        if (\n          isDepthTextureFormat(t.format) &&\n          canBuiltinTakeTextureDepth(t.func) &&\n          t.aspect === 'depth-only'\n        ) {\n          yield `texture_depth_2d`;\n        }\n      })\n      .expand('channel', function* (t) {\n        if (t.func === 'textureGather' && !isSingleChannelInput(t.input)) {\n          yield 0;\n          yield 1;\n          yield 2;\n          yield 3;\n        } else {\n          yield 0;\n        }\n      })\n      .combine('swizzleSpec', kSwizzleTests)\n      .combine('otherSwizzleIndexOffset', [0, 1, 5]) // used to choose a different 2nd swizzle. 0 = same swizzle as 1st\n      // Don't test swizzles that have no defined results. (eg. depth16unorm with `gggg`)\n      .unless(\n        t =>\n          noDefinedResults(t.swizzleSpec, t.format, t.func, t.input, t.channel) &&\n          noDefinedResults(\n            getSwizzleSpecByOffsetFromSwizzleSpec(t.swizzleSpec, t.otherSwizzleIndexOffset),\n            t.format,\n            t.func,\n            t.input,\n            t.channel\n          )\n      )\n  )\n  .fn(async t => {\n    // MAINTENANCE_TODO: Remove this cast once texture-component-swizzle is added to @webgpu/types\n    t.skipIfDeviceDoesNotHaveFeature('texture-component-swizzle' as GPUFeatureName);\n    const { format, func, channel, compare, input, aspect, swizzleSpec, otherSwizzleIndexOffset } =\n      t.params;\n    t.skipIfTextureFormatNotSupported(format);\n\n    const otherSwizzleSpec = getSwizzleSpecByOffsetFromSwizzleSpec(\n      swizzleSpec,\n      otherSwizzleIndexOffset\n    );\n    const swizzle = swizzleSpecToGPUTextureComponentSwizzle(swizzleSpec);\n    const otherSwizzle = swizzleSpecToGPUTextureComponentSwizzle(otherSwizzleSpec);\n\n    t.skipIf(\n      t.isCompatibility && !swizzlesAreTheSame(swizzle, otherSwizzle),\n      `swizzles must be equivalent in compatibility mode: ${swizzleSpec} != ${otherSwizzleSpec}`\n    );\n\n    const depthRef = 0.5;\n    const size = chooseTextureSize({ minSize: 2, minBlocks: 2, format });\n    const { blockWidth, blockHeight } = getBlockInfoForTextureFormat(format);\n    // Choose a texture coordinate that will cross a block boundary for gather.\n    // This is because we only create solid color blocks for some formats so we\n    // won't get a different color per channel unless we sample across blocks.\n    const tx = blockWidth - 0.4;\n    const ty = blockHeight - 0.4;\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels: srcTexelViews, texture } =\n      await createTextureWithRandomDataAndGetTexelsForEachAspect(t, descriptor);\n    const aspectNdx = isDepthStencilTextureFormat(format) && aspect === 'stencil-only' ? 1 : 0;\n    const srcTexelView = srcTexelViews[aspectNdx];\n\n    const samples = [];\n    const sampledColors = range(4, i => {\n      const x = (tx | 0) + (i % 2);\n      const y = (ty | 0) + ((i / 2) | 0);\n\n      const sample = srcTexelView[0].color({ x, y, z: 0 });\n      samples.push(sample);\n      return convertPerTexelComponentToResultFormat(sample, format, aspect);\n    });\n    t.debug(\n      () => `samples:\n${sampledColors.map((c, i) => `${i % 2}, ${(i / 2) | 0}, ${JSON.stringify(c)}`).join('\\n')}`\n    );\n\n    const components = [TexelComponent.R, TexelComponent.G, TexelComponent.B, TexelComponent.A];\n    const readColors = sampledColors.map(sampledColor =>\n      isBuiltinComparison(func)\n        ? applyCompareToTexel(components, sampledColor, compare, depthRef)\n        : sampledColor\n    );\n\n    const {\n      resultType,\n      sampleType: srcSampleType,\n      resultFormat: expFormat,\n    } = getTextureFormatTypeInfo(format, aspect);\n\n    const testData = [swizzle, otherSwizzle].map(swizzle => {\n      const validMask = makeValidMaskAndAltResultForFormatSwizzle(\n        swizzle,\n        format,\n        func,\n        input,\n        channel\n      );\n      const swizzledColors = readColors.map(readColor => swizzleTexel(readColor, swizzle));\n      const gatheredColor = isBuiltinGather(func)\n        ? gather(swizzledColors, channel)\n        : swizzledColors[0];\n      const expRGBAColor = applyValidMask(gatheredColor, validMask);\n      const expColor =\n        !isBuiltinGather(func) && isSingleChannelInput(input)\n          ? {\n              R: expRGBAColor.R,\n              G: expRGBAColor.R,\n              B: expRGBAColor.R,\n              A: expRGBAColor.R,\n            }\n          : expRGBAColor;\n      const expTexelView = TexelView.fromTexelsAsColors(expFormat, _coords => expColor);\n      const textureView = texture.createView({ swizzle, aspect });\n\n      // BA  in a 2x2 texel area this is\n      // RG  the order of gather.\n      t.debug(\n        () => `\\\n  swizzleSpec: ${swizzleSpec}, channel: ${channel}, compare: ${compare}\n  readColors:\n${readColors\n  .map((c, i) => `${i % 2}, ${(i / 2) | 0}, ${JSON.stringify(c)} ${kGatherComponentOrder[i]}`)\n  .join('\\n')}\n  swizzledColors:\n${swizzledColors\n  .map((c, i) => `${i % 2}, ${(i / 2) | 0}, ${JSON.stringify(c)} ${kGatherComponentOrder[i]}`)\n  .join('\\n')}\n  `\n      );\n      return { swizzleSpec, swizzle, expColor, expFormat, expTexelView, textureView, validMask };\n    });\n\n    t.debug(\n      () => `expColors:\n${testData\n  .map(({ expColor }, i) => `${i % 2}, ${(i / 2) | 0}, ${JSON.stringify(expColor)}`)\n  .join('\\n')}`\n    );\n\n    const loadFn = ((func: TextureBuiltin) => {\n      switch (func) {\n        case 'textureGather':\n          return (v: number) =>\n            isSingleChannelInput(input)\n              ? `textureGather(tex${v}, smp, uni.texCoord)`\n              : `textureGather(${channel}, tex${v}, smp, uni.texCoord)`;\n        case 'textureGatherCompare':\n          return (v: number) => `textureGatherCompare(tex${v}, smp, uni.texCoord, ${depthRef})`;\n        case 'textureLoad':\n          return (v: number) =>\n            `textureLoad(tex${v}, vec2u(uni.texCoord * vec2f(textureDimensions(tex${v}))), 0)`;\n        case 'textureSample':\n          return (v: number) => `textureSample(tex${v}, smp, uni.texCoord)`;\n        case 'textureSampleBias':\n          return (v: number) => `textureSampleBias(tex${v}, smp, uni.texCoord, 0)`;\n        case 'textureSampleCompare':\n          return (v: number) => `textureSampleCompare(tex${v}, smp, uni.texCoord, ${depthRef})`;\n        case 'textureSampleCompareLevel':\n          return (v: number) =>\n            `textureSampleCompareLevel(tex${v}, smp, uni.texCoord, ${depthRef})`;\n        case 'textureSampleGrad':\n          return (v: number) => `textureSampleGrad(tex${v}, smp, uni.texCoord, vec2f(0), vec2f(0))`;\n        case 'textureSampleLevel':\n          return (v: number) => `textureSampleLevel(tex${v}, smp, uni.texCoord, 0)`;\n        default:\n          throw new Error(`Unsupported texture builtin function: ${func}`);\n      }\n    })(func);\n    const loadWGSL = (v: number) => `${resultType}(${loadFn(v)})`;\n\n    const samplerWGSL = isBuiltinComparison(func) ? 'sampler_comparison' : 'sampler';\n    const code = `\n      // from the spec: https://gpuweb.github.io/gpuweb/#reading-depth-stencil\n      // depth and stencil values are D, ?, ?, ?\n      // so for these formats, for each swizzle that references g, b, or a\n      // we set validMask to 0 (0 = not valid). If that channel is not valid\n      // we return the altResult for that channel. altResult is effectively\n      // swizzle(vec4(0, 0, 0, 1)) since that is what is in expColor.\n\n      struct ValidMaskAndAltResult {\n        validMask: vec4u,\n        altResult: vec4u,\n      };\n\n      struct Uniforms {\n        validMasks: array<ValidMaskAndAltResult, 2>,\n        texCoord: vec2f,\n      };\n\n      // These are intentionally in different bindGroups to test in compat that different swizzles\n      // of the same texture are not allowed.\n      @group(0) @binding(0) var tex0: ${input};\n      @group(1) @binding(0) var tex1: ${input};\n      @group(0) @binding(1) var smp: ${samplerWGSL};\n      @group(0) @binding(2) var<uniform> uni: Uniforms;\n      @group(0) @binding(3) var result: texture_storage_2d<${expFormat}, write>;\n\n      fn maskMix(v: ${resultType}, maskAlt: ValidMaskAndAltResult) -> ${resultType} {\n        let alt = ${resultType}(maskAlt.altResult);\n        return ${resultType}(\n          select(alt.x, v.x, maskAlt.validMask.x != 0u),\n          select(alt.y, v.y, maskAlt.validMask.y != 0u),\n          select(alt.z, v.z, maskAlt.validMask.z != 0u),\n          select(alt.w, v.w, maskAlt.validMask.w != 0u),\n        );\n      }\n\n      @vertex fn vsFSResults() -> @builtin(position) vec4f {\n        return vec4f(0, 0, 0, 1);\n      }\n\n      @fragment fn fsFSResults() -> @location(0) vec4f {\n        let c0 = maskMix(${loadWGSL(0)}, uni.validMasks[0]);\n        let c1 = maskMix(${loadWGSL(1)}, uni.validMasks[1]);\n        textureStore(result, vec2u(0, 0), c0);\n        textureStore(result, vec2u(1, 0), c1);\n        return vec4f(0, 0, 0, 1);\n      }\n    `;\n\n    const sampleType = isSingleChannelInput(input)\n      ? 'depth'\n      : srcSampleType === 'depth'\n      ? isBuiltinComparison(func)\n        ? 'depth'\n        : 'unfilterable-float'\n      : srcSampleType;\n    const samplerType = isBuiltinComparison(func) ? 'comparison' : 'non-filtering';\n\n    const pipelineId = `${sampleType}:${samplerType}${code}`;\n    const cache = s_deviceToPipelines.get(t.device) ?? new Map();\n    s_deviceToPipelines.set(t.device, cache);\n    let pipeline = cache.get(pipelineId);\n    if (!pipeline) {\n      const module = t.device.createShaderModule({ code });\n\n      const bgl0 = t.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n            texture: {\n              sampleType,\n            },\n          },\n          {\n            binding: 1,\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n            sampler: {\n              type: samplerType,\n            },\n          },\n          {\n            binding: 2,\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n            buffer: {},\n          },\n          {\n            binding: 3,\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n            storageTexture: {\n              format: expFormat,\n            },\n          },\n        ],\n      });\n\n      const bgl1 = t.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n            texture: {\n              sampleType,\n            },\n          },\n        ],\n      });\n\n      const layout = t.device.createPipelineLayout({\n        bindGroupLayouts: [bgl0, bgl1],\n      });\n\n      pipeline = t.device.createRenderPipeline({\n        layout,\n        vertex: { module },\n        fragment: { module, targets: [{ format: 'rgba8unorm' }] },\n        primitive: { topology: 'point-list' },\n      });\n      cache.set(pipelineId, pipeline);\n    }\n\n    const outputTexture = t.createTextureTracked({\n      format: expFormat,\n      size: [2],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.STORAGE_BINDING,\n    });\n\n    const sampler = t.device.createSampler(\n      isBuiltinComparison(func)\n        ? {\n            compare,\n          }\n        : {}\n    );\n\n    const uniformBuffer = t.createBufferTracked({\n      size: (4 * 2 * 2 + 2 + 2) * 4, // vec4u * 2 * 2 + vec2f + padding\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    const uniformValues = new ArrayBuffer(uniformBuffer.size);\n    const asU32 = new Uint32Array(uniformValues);\n    const asF32 = new Float32Array(uniformValues);\n    asU32.set(\n      testData.map(({ validMask }) => [...validMask.validMask, ...validMask.altResult]).flat()\n    );\n    asF32.set([tx / texture.width, ty / texture.height], 16);\n    t.device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array(uniformValues));\n\n    const bindGroup0 = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: testData[0].textureView },\n        { binding: 1, resource: sampler },\n        { binding: 2, resource: uniformBuffer },\n        { binding: 3, resource: outputTexture },\n      ],\n    });\n\n    const bindGroup1 = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(1),\n      entries: [{ binding: 0, resource: testData[1].textureView }],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: t.createTextureTracked({\n            format: 'rgba8unorm',\n            size: [1],\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\n          }),\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup0);\n    pass.setBindGroup(1, bindGroup1);\n    pass.draw(1);\n    pass.end();\n\n    if (t.isCompatibility && !swizzlesAreTheSame(testData[0].swizzle, testData[1].swizzle)) {\n      // Swizzles can not be different in compatibility mode\n      t.expectValidationError(() => {\n        t.device.queue.submit([encoder.finish()]);\n      });\n    } else {\n      t.device.queue.submit([encoder.finish()]);\n\n      testData.forEach(({ swizzleSpec, expTexelView }, i) => {\n        t.debug(() => `${i}: ${swizzleSpec} ${JSON.stringify(testData[i].validMask)}`);\n\n        ttu.expectTexelViewComparisonIsOkInTexture(\n          t,\n          { texture: outputTexture, origin: [i, 0, 0] },\n          expTexelView,\n          [1, 1, 1],\n          { maxFractionalDiff: 0.01 }\n        );\n      });\n    }\n  });\n"],"mappings":"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"}