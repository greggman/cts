{"version":3,"file":"textureSampleBias.spec.js","names":["description","makeTestGroup","isFilterableAsTextureF32","kAllTextureFormats","TextureTestMixin","clamp","generateTextureBuiltinInputs2D","generateTextureBuiltinInputs3D","kSamplePointMethods","kShortAddressModes","kShortAddressModeToAddressMode","doTextureCalls","checkCallResults","createTextureWithRandomDataAndGetTexels","generateSamplePointsCube","kCubeSamplePointMethods","chooseTextureSize","isPotentiallyFilterableAndFillable","skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable","getTextureTypeForTextureViewDimension","WGSLTextureSampleTest","isSupportedViewFormatCombo","skipIfNeedsFilteringAndIsUnfilterable","g","makeGraph","width","height","data","Uint8Array","plot","norm","x","c","y","Math","floor","min","max","offset","plotValues","values","i","v","toString","conversion","lines","push","subarray","map","join","safeStr","undefined","pad","format","len","padStart","padEnd","padColumns","rows","formats","columnLengths","row","forEach","length","test","desc","fn","t","device","biases","module","createShaderModule","code","pipeline","createRenderPipeline","layout","vertex","fragment","targets","sampler","createSampler","minFilter","magFilter","mipmapFilter","Float32Array","bias","mipLevel","derivativeBasedMipLevel","derivativeMult","pow","dataBuffer","createBufferTracked","size","byteLength","usage","GPUBufferUsage","UNIFORM","COPY_DST","queue","writeBuffer","sizes","buffers","Promise","all","texture","createTextureTracked","GPUTextureUsage","TEXTURE_BINDING","mipLevelCount","ones","fill","writeTexture","bytesPerRow","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","buffer","resultTexture","COPY_SRC","RENDER_ATTACHMENT","resultBuffer","MAP_READ","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","loadOp","storeOp","setPipeline","setBindGroup","setViewport","draw","end","copyTextureToBuffer","submit","finish","mapAsync","GPUMapMode","READ","graph","results","getMappedRange","j","toFixed","info","String","fromCodePoint","expectOK","Error","specURL","params","u","combine","filter","filt","beginSubcases","beforeAllSubcases","samplePoints","modeU","modeV","minSize","minBlocks","descriptor","texels","addressModeU","addressModeV","calls","method","hashInputs","coords","builtin","coordType","viewDescriptor","textureType","res","dim","viewDimension","modeW","dimension","isCompatibility","textureBindingViewDimension","addressModeW","A","depthOrArrayLayers","arrayIndex","num","type","arrayIndexType","skipIfTextureViewDimensionNotSupported","mode"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureSampleBias.spec.ts"],"sourcesContent":["export const description = `\nExecution tests for the 'textureSampleBias' builtin function\n\nSamples a texture with a bias to the mip level.\n\n- TODO: test cube maps with more than one mip level.\n- TODO: Test un-encodable formats.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { isFilterableAsTextureF32, kAllTextureFormats } from '../../../../../format_info.js';\nimport { TextureTestMixin } from '../../../../../gpu_test.js';\nimport { clamp } from '../../../../../util/math.js';\n\nimport {\n  vec2,\n  vec3,\n  TextureCall,\n  generateTextureBuiltinInputs2D,\n  generateTextureBuiltinInputs3D,\n  kSamplePointMethods,\n  kShortAddressModes,\n  kShortAddressModeToAddressMode,\n  doTextureCalls,\n  checkCallResults,\n  createTextureWithRandomDataAndGetTexels,\n  generateSamplePointsCube,\n  kCubeSamplePointMethods,\n  SamplePointMethods,\n  chooseTextureSize,\n  isPotentiallyFilterableAndFillable,\n  skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable,\n  getTextureTypeForTextureViewDimension,\n  WGSLTextureSampleTest,\n  isSupportedViewFormatCombo,\n  skipIfNeedsFilteringAndIsUnfilterable,\n} from './texture_utils.js';\n\nexport const g = makeTestGroup(TextureTestMixin(WGSLTextureSampleTest));\n\nfunction makeGraph(width: number, height: number) {\n  const data = new Uint8Array(width * height);\n\n  return {\n    plot(norm: number, x: number, c: number) {\n      const y = clamp(Math.floor(norm * height), { min: 0, max: height - 1 });\n      const offset = (height - y - 1) * width + x;\n      data[offset] = c;\n    },\n    plotValues(values: Iterable<number>, c: number) {\n      let i = 0;\n      for (const v of values) {\n        this.plot(v, i, c);\n        ++i;\n      }\n    },\n    toString(conversion = ['.', 'e', 'A']) {\n      const lines = [];\n      for (let y = 0; y < height; ++y) {\n        const offset = y * width;\n        lines.push([...data.subarray(offset, offset + width)].map(v => conversion[v]).join(''));\n      }\n      return lines.join('\\n');\n    },\n  };\n}\n\nfunction safeStr(v?: string | number) {\n  return v === undefined ? 'undefined' : v.toString();\n}\n\nfunction pad(format: string, len: number, v: string | number) {\n  switch (format) {\n    case '>': // move to right\n    case 'r': // pad right\n    case 's': // pad start\n      return safeStr(v).padStart(len);\n    default:\n      return safeStr(v).padEnd(len);\n  }\n}\n\nfunction padColumns(rows: (string | number)[][], formats = '') {\n  const columnLengths: number[] = [];\n\n  // get size of each column\n  for (const row of rows) {\n    row.forEach((v, i) => {\n      columnLengths[i] = Math.max(columnLengths[i] || 0, safeStr(v).length);\n    });\n  }\n\n  return rows\n    .map(row => row.map((v, i) => pad(formats[i], columnLengths[i], v)).join(''))\n    .join('\\n');\n}\n\ng.test('info')\n  .desc(\n    `\n    test various bias settings for a given mip level with different texture sizes\n`\n  )\n  .fn(async t => {\n    const { device } = t;\n    const biases = [\n      -16, -15.9, -15.8, -15, 8, 9, 10, 11, 12, 12.125, 12.25, 12.5, 12.75, 13, 14, 15, 15.99,\n    ];\n\n    const module = device.createShaderModule({\n      code: `\nstruct VOut {\n  @builtin(position) pos: vec4f,\n  @location(0) @interpolate(flat, either) ndx: u32,\n  @location(1) @interpolate(flat, either) result: vec4<f32>,\n};\n\nstruct Data {\n  derivativeMult: f32,\n  bias: f32,\n  pad0: f32,\n  pad1: f32,\n};\n\n@group(0) @binding(0) var          T    : texture_2d<f32>;\n@group(0) @binding(1) var          S    : sampler;\n@group(0) @binding(2) var<uniform> data : array<Data, ${biases.length}>;\n\nfn getResult(idx: u32, derivativeBase: vec2f) -> vec4<f32> {\n  let args = data[idx];\n  return textureSampleBias(T, S, vec2f(0.5) + derivativeBase * vec2f(args.derivativeMult, 0), args.bias);\n}\n\n// --------------------------- fragment stage shaders --------------------------------\n@vertex fn vsFragment(\n    @builtin(vertex_index) vertex_index : u32,\n    @builtin(instance_index) instance_index : u32) -> VOut {\n  let positions = array(vec2f(-1, 3), vec2f(3, -1), vec2f(-1, -1));\n  return VOut(vec4f(positions[vertex_index], 0, 1), instance_index, vec4<f32>(0));\n}\n\n@fragment fn fsFragment(v: VOut) -> @location(0) vec4u {\n  let derivativeBase = (v.pos.xy - 0.5 - vec2f(f32(v.ndx), 0)) / vec2f(textureDimensions(T));\n  return bitcast<vec4u>(getResult(v.ndx, derivativeBase));\n  //return bitcast<vec4u>(vec4f(data[v.ndx].bias));\n}\n      `,\n    });\n\n    const pipeline = device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module },\n      fragment: { module, targets: [{ format: 'rgba32uint' }] },\n    });\n\n    const sampler = device.createSampler({\n      minFilter: 'linear',\n      magFilter: 'linear',\n      mipmapFilter: 'linear',\n    });\n\n    const data = new Float32Array(biases.length * 4);\n    biases.forEach((bias, i) => {\n      const mipLevel = 0.5;\n      const derivativeBasedMipLevel = mipLevel - bias;\n      const derivativeMult = Math.pow(2, derivativeBasedMipLevel);\n      const offset = i * 4;\n      data[offset + 0] = derivativeMult;\n      data[offset + 1] = bias;\n    });\n\n    const dataBuffer = t.createBufferTracked({\n      size: data.byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(dataBuffer, 0, data);\n\n    const sizes = [2, 4, 8, 12, 16, 24, 32, 40, 128];\n    const buffers: GPUBuffer[] = [];\n    await Promise.all(\n      sizes.map(size => {\n        const texture = t.createTextureTracked({\n          size: [size, size],\n          format: 'r8unorm',\n          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n          mipLevelCount: 2,\n        });\n\n        // fill mip level 1 with ones\n        const ones = new Uint8Array((texture.width / 2) * (texture.height / 2)).fill(255);\n        device.queue.writeTexture({ texture, mipLevel: 1 }, ones, { bytesPerRow: size / 2 }, [\n          size / 2,\n          size / 2,\n        ]);\n\n        const bindGroup = device.createBindGroup({\n          layout: pipeline.getBindGroupLayout(0),\n          entries: [\n            { binding: 0, resource: texture.createView() },\n            { binding: 1, resource: sampler },\n            { binding: 2, resource: { buffer: dataBuffer } },\n          ],\n        });\n\n        const resultTexture = t.createTextureTracked({\n          size: [biases.length, 1],\n          format: 'rgba32uint',\n          usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n\n        const resultBuffer = t.createBufferTracked({\n          size: resultTexture.width * 4 * 4,\n          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n\n        const encoder = device.createCommandEncoder();\n        const pass = encoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: resultTexture.createView(),\n              loadOp: 'clear',\n              storeOp: 'store',\n            },\n          ],\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindGroup);\n        for (let i = 0; i < biases.length; ++i) {\n          pass.setViewport(i, 0, 1, 1, 0, 1);\n          pass.draw(3, 1, 0, i);\n        }\n        pass.end();\n        encoder.copyTextureToBuffer(\n          { texture: resultTexture },\n          {\n            buffer: resultBuffer,\n          },\n          [biases.length, 1]\n        );\n        device.queue.submit([encoder.finish()]);\n        buffers.push(resultBuffer);\n        return resultBuffer.mapAsync(GPUMapMode.READ);\n      })\n    );\n\n    const graph = makeGraph(biases.length, 20);\n\n    const rows: (number | string)[][] = [['bias->', ...biases.map(v => `|${v}`)]];\n    rows.push(rows[0].map(v => '|-------'));\n    sizes.forEach((size, i) => {\n      const results = new Float32Array(buffers[i].getMappedRange());\n      const row: (number | string)[] = [`size:${size}`];\n      for (let j = 0; j < results.length; j += 4) {\n        graph.plot((1 - results[j] - 0.4) / 0.2, j / 4, i + 1);\n        row.push(`|${(1 - results[j]).toFixed(5)}`);\n      }\n      rows.push(row);\n    });\n\n    t.info(`\\n${padColumns(rows)}`);\n    t.info(`\\n${graph.toString(['.', ...biases.map((v, i) => String.fromCodePoint(97 + i))])}`);\n    t.expectOK(new Error('info'));\n  });\n\ng.test('sampled_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplebias')\n  .desc(\n    `\nfn textureSampleBias(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, bias: f32) -> vec4<f32>\nfn textureSampleBias(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, bias: f32, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * bias: The bias to apply to the mip level before sampling. bias must be between -16.0 and 15.99.\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n  )\n  .beforeAllSubcases(t =>\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format)\n  )\n  .fn(async t => {\n    const { format, samplePoints, modeU, modeV, filt: minFilter, offset } = t.params;\n    skipIfNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      sampler,\n      method: samplePoints,\n      descriptor,\n      bias: true,\n      offset,\n      hashInputs: [format, samplePoints, modeU, modeV, minFilter, offset],\n    }).map(({ coords, derivativeMult, offset, bias }) => {\n      return {\n        builtin: 'textureSampleBias',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        bias,\n        offset,\n      };\n    });\n\n    const viewDescriptor = {};\n    const textureType = 'texture_2d<f32>';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplebias')\n  .desc(\n    `\nfn textureSampleBias(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>\nfn textureSampleBias(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, bias: f32, offset: vec3<i32>) -> vec4<f32>\nfn textureSampleBias(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>\n\nParameters:\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * bias: The bias to apply to the mip level before sampling. bias must be between -16.0 and 15.99.\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('dim', ['3d', 'cube'] as const)\n      .filter(t => isSupportedViewFormatCombo(t.format, t.dim))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('modeW', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .filter(t => t.dim !== 'cube' || t.offset !== true)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .filter(t => t.samplePoints !== 'cube-edges' || t.dim !== '3d')\n  )\n  .beforeAllSubcases(t =>\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format)\n  )\n  .fn(async t => {\n    const {\n      format,\n      dim: viewDimension,\n      samplePoints,\n      modeU,\n      modeV,\n      modeW,\n      filt: minFilter,\n      offset,\n    } = t.params;\n    skipIfNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    const size = chooseTextureSize({ minSize: 8, minBlocks: 2, format, viewDimension });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      dimension: viewDimension === '3d' ? '3d' : '2d',\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size,\n      // MAINTENANCE_TODO: use 3 for cube maps when derivatives are supported for cube maps.\n      mipLevelCount: viewDimension === '3d' ? 3 : 1,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      addressModeW: kShortAddressModeToAddressMode[modeW],\n      minFilter,\n      magFilter: minFilter,\n    };\n\n    const hashInputs = [\n      format,\n      viewDimension,\n      samplePoints,\n      modeU,\n      modeV,\n      modeW,\n      minFilter,\n      offset,\n    ];\n    const calls: TextureCall<vec3>[] = (\n      viewDimension === '3d'\n        ? generateTextureBuiltinInputs3D(50, {\n            method: samplePoints as SamplePointMethods,\n            sampler,\n            descriptor,\n            bias: true,\n            offset,\n            hashInputs,\n          })\n        : generateSamplePointsCube(50, {\n            method: samplePoints,\n            sampler,\n            descriptor,\n            bias: true,\n            hashInputs,\n          })\n    ).map(({ coords, derivativeMult, offset, bias }) => {\n      return {\n        builtin: 'textureSampleBias',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        bias,\n        offset,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('arrayed_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplebias')\n  .desc(\n    `\nA: i32, u32\n\nfn textureSampleBias(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: A, bias: f32) -> vec4<f32>\nfn textureSampleBias(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: A, bias: f32, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * array_index: The 0-based texture array index to sample.\n * bias: The bias to apply to the mip level before sampling. bias must be between -16.0 and 15.99.\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .beforeAllSubcases(t =>\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format)\n  )\n  .fn(async t => {\n    const { format, samplePoints, A, modeU, modeV, filt: minFilter, offset } = t.params;\n    skipIfNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const depthOrArrayLayers = 4;\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      bias: true,\n      offset,\n      hashInputs: [format, samplePoints, A, modeU, modeV, minFilter, offset],\n    }).map(({ coords, derivativeMult, arrayIndex, bias, offset }) => {\n      return {\n        builtin: 'textureSampleBias',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        bias,\n        offset,\n      };\n    });\n    const textureType = 'texture_2d_array<f32>';\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('arrayed_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplebias')\n  .desc(\n    `\nA: i32, u32\n\nfn textureSampleBias(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: A, bias: f32) -> vec4<f32>\n\nParameters:\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * array_index: The 0-based texture array index to sample.\n * bias: The bias to apply to the mip level before sampling. bias must be between -16.0 and 15.99.\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isFilterableAsTextureF32(t.format))\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .beforeAllSubcases(t => {\n    skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(t, t.params.format);\n    t.skipIfTextureViewDimensionNotSupported('cube-array');\n  })\n  .fn(async t => {\n    const { format, samplePoints, A, mode, filt: minFilter } = t.params;\n    skipIfNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    const viewDimension: GPUTextureViewDimension = 'cube-array';\n    const size = chooseTextureSize({\n      minSize: 32,\n      minBlocks: 4,\n      format,\n      viewDimension,\n    });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      // MAINTENANCE_TODO: use 3 for cube maps when derivatives are supported for cube maps.\n      mipLevelCount: 1,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      bias: true,\n      arrayIndex: { num: texture.depthOrArrayLayers / 6, type: A },\n      hashInputs: [format, viewDimension, A, samplePoints, mode, minFilter],\n    }).map(({ coords, derivativeMult, arrayIndex, bias }) => {\n      return {\n        builtin: 'textureSampleBias',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        bias,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n"],"mappings":"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"}